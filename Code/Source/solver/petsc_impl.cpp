
/* Copyright (c) Stanford University, The Regents of the University of California, and others.
 *
 * All Rights Reserved.
 *
 * See Copyright-SimVascular.txt for additional details.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// This file contains PetscImpl and PETSc-dependent functions. 

#include "petsc_impl.h"
#include <locale.h>

LHSCtx plhs;             /* PETSc lhs */
LSCtx *psol;             /* PETSc solver */
BlockIterative_Preconditioner *block_PC = nullptr; /* Block iterative preconditioner */

PetscLogStage stages[6]; /* performance tuning. */

/*
    Nomenclature used in this file:
    - global: across all MPI processes
    - local: current MPI processes
    - natural id: global vertex id from mesh file
    - PETSc id: global vertex id used within PETSc
    - O1 ordering: the local order of natural id generated by ParMetis in svFSI
    - O2 ordering: reorder O1 to "(vertex shared with lower rank)  + 
                   (vertex owned exclusively by current rank) + 
                   (vertex shared with higher rank)"
    - owned vertices: "(vertex shared with lower rank)  + 
                      (vertex owned exclusively by current rank)" 
                      forms the vertices owned by the current rank.
    - ghost vertices: vertex shared with higher rank 

    The mapping between different ordering is
        O1 --> O2 --> PETSc ID
*/

// Initialize PETSc and create lhs for PETSc.
//
void petsc_initialize(const PetscInt nNo, const PetscInt mynNo, const PetscInt nnz, 
    const PetscInt nEq, const PetscInt *svFSI_ltg, const PetscInt *svFSI_map, 
    const PetscInt *svFSI_rowPtr, const PetscInt *svFSI_colPtr, char *inp)
{   
    // char* in_file = rm_blank(inp);
    char *in_file = inp;
    if (access(in_file, F_OK) == 0) {
        PetscInitialize(NULL, NULL, in_file, NULL);
        PetscPrintf(MPI_COMM_WORLD, " <PETSC_INITIALIZE>: "
                "use linear solver config. from file.\n");
    }
    else
    {
        PetscInitialize(NULL, NULL, NULL, NULL);
        PetscPrintf(MPI_COMM_WORLD, " <PETSC_INITIALIZE>: "
                                    "use linear solver config. from svFSI input.\n");
    }

    PetscLogStageRegister("Create LHS", &stages[0]);
    PetscLogStageRegister("Create VecMat", &stages[1]);
    PetscLogStageRegister("Create Solver", &stages[2]);
    PetscLogStageRegister("Set Values", &stages[3]);
    PetscLogStageRegister("PETSc Solve", &stages[4]);
    PetscLogStageRegister("Row-Col. Sca.", &stages[5]);

    PetscLogStagePush(stages[0]);

    plhs.created = PETSC_FALSE;
    petsc_create_lhs(nNo, mynNo, nnz, svFSI_ltg, svFSI_map, svFSI_rowPtr, svFSI_colPtr);

    PetscMalloc1(nEq, &psol);

    for (PetscInt i = 0; i < nEq; i++)
    {
        psol[i].created = PETSC_FALSE;
    }

    PetscLogStagePop();
}

/*
    Create parallel vector and matrix data structures.
*/
void petsc_create_linearsystem(const PetscInt dof, const PetscInt iEq, const PetscInt nEq,
                               const PetscReal *svFSI_DirBC, PetscReal** svFSI_lpBC, const PetscInt nFacesRes)                    
{
    // PetscInt cEq = *iEq - 1;
    PetscInt cEq = iEq; // in Fortran, cEq = 1; in C++, cEq = 0;

    if (psol[cEq].created)
    {
        return;
    }

    PetscLogStagePush(stages[1]);

    psol[cEq].nResFaces = nFacesRes;        
    if (psol[cEq].block_iterative_pc)
    {
        petsc_create_splitbc(dof, cEq, svFSI_DirBC, svFSI_lpBC); /* bc info is required for mat_create */
        petsc_create_splitvecmat(dof, cEq, nEq);
    } else 
    {
        petsc_create_bc(dof, cEq, svFSI_DirBC, svFSI_lpBC); /* bc info is required for mat_create */
        petsc_create_vecmat(dof, cEq, nEq);
    }
    psol[cEq].created = PETSC_TRUE;
    PetscLogStagePop();
}

/*
    Create PETSc linear solver data.
*/
void petsc_create_linearsolver(const consts::SolverType lsType, const consts::PreconditionerType pcType, const BlockIterativePCparams pc_params,
                               const PetscInt kSpace, const PetscInt maxIter, const PetscReal relTol, const PetscReal absTol,
                               const consts::EquationType phys, const PetscInt dof, const PetscInt nnz, const PetscInt iEq, const PetscInt nEq)
{
    using namespace consts;

    // PetscInt cEq = *iEq - 1;
    PetscInt cEq = iEq; // in Fortran, cEq = 1; in C++, cEq = 0;
    PC pc;
    PetscBool usefieldsplit;

    PetscLogStagePush(stages[2]);

    /* Initialize equation specific prefix for vec/mat/ksp */
    switch (phys)
    {
    case EquationType::phys_fluid:
        psol[cEq].pre = "ns_";
        break;
    case EquationType::phys_struct:
        psol[cEq].pre = "st_";
        break;
    case EquationType::phys_heatS:
        psol[cEq].pre = "hs_";
        break;
    case EquationType::phys_lElas:
        psol[cEq].pre = "le_";
        break;
    case EquationType::phys_heatF:
        psol[cEq].pre = "hf_";
        break;
    case EquationType::phys_FSI:
        psol[cEq].pre = "fs_";
        break;
    case EquationType::phys_mesh:
        psol[cEq].pre = "ms_";
        break;
    case EquationType::phys_shell:
        psol[cEq].pre = "sh_";
        break;
    case EquationType::phys_CMM:
        psol[cEq].pre = "cm_";
        break;
    case EquationType::phys_CEP:
        psol[cEq].pre = "ep_";
        break;
    case EquationType::phys_ustruct:
        psol[cEq].pre = "st_";
        break;
    case EquationType::phys_stokes:
        psol[cEq].pre = "ss_";
        break;
    default:
        PetscPrintf(MPI_COMM_WORLD, "ERROR <PETSC_CREATE_LINEARSOLVER>: "
                                    "equation type %d is not defined.\n",
                    phys);
        break;
    }

    /* Initialize PETSc linear solver setting */
    KSPCreate(MPI_COMM_WORLD, &psol[cEq].ksp);

    if (nEq > 1)
    {
        KSPSetOptionsPrefix(psol[cEq].ksp, psol[cEq].pre);
    }

    KSPSetTolerances(psol[cEq].ksp, relTol, absTol, PETSC_DEFAULT, maxIter);

    // Set the linear solver.

    switch (lsType)
    {
    case SolverType::lSolver_CG:
        KSPSetType(psol[cEq].ksp, KSPCG);
        break;
    case SolverType::lSolver_GMRES:
        KSPSetType(psol[cEq].ksp, KSPGMRES);
        //            KSPGMRESSetRestart(psol[cEq].ksp, *kSpace);
        break;
    case SolverType::lSolver_BICGS:
        KSPSetType(psol[cEq].ksp, KSPBCGS);
        break;
    case SolverType::lSolver_FGMRES:
        KSPSetType(psol[cEq].ksp, KSPFGMRES);
        break;
    default:
        PetscPrintf(MPI_COMM_WORLD, "ERROR <PETSC_CREATE_LINEARSOLVER>: "
                                    "linear solver type not supported through svFSI input file.\n"
                                    "ERROR <PETSC_CREATE_LINEARSOLVER>: "
                                    "More linear solver types can be set through petsc_option.inp.\n");
        break;
    }

    /* Set preconditioner */
    psol[cEq].block_iterative_pc = PETSC_FALSE;
    psol[cEq].rcs = PETSC_FALSE;
    KSPGetPC(psol[cEq].ksp, &pc);

    switch (pcType)
    {
    case PreconditionerType::PREC_PETSC_JACOBI:
        PCSetType(pc, PCJACOBI);
    break;

    case PreconditionerType::PREC_PETSC_BJACOBI:
        PCSetType(pc, PCBJACOBI);
    break;

    case PreconditionerType::PREC_PETSC_AMG:
        PCSetType(pc, PCHYPRE);
        PCHYPRESetType(pc, "boomeramg");
    break;

    case PreconditionerType::PREC_PETSC_SCR: // To be used with FGMRES solver
    {
        psol[cEq].block_iterative_pc = PETSC_TRUE;

        std::string block_pc_type = consts::preconditioner_type_to_name.at(pcType);
        
        auto it = block_iterative_pc_map.find(block_pc_type);
        
        if (it != block_iterative_pc_map.end()) {
            block_PC = it->second(pc);  // Create and store the block preconditioner
            block_PC->CreatePC();
            block_PC->initialize_solvers(pc_params.relTol_0, pc_params.absTol_0, 1.0e50, pc_params.mItr_0, 
                pc_params.prec_0, pc_params.relTol_1, pc_params.absTol_1, 1.0e50, pc_params.mItr_1, pc_params.prec_1);
        } else {
            throw std::runtime_error("Error: Unknown block-iterative preconditioner type:" + block_pc_type + ".");
        }
    }
    break;

    case PreconditionerType::PREC_PETSC_SIMPLE: // To be used with FGMRES solver
    {
        psol[cEq].block_iterative_pc = PETSC_TRUE;

        std::string block_pc_type = consts::preconditioner_type_to_name.at(pcType);
        
        auto it = block_iterative_pc_map.find(block_pc_type);
        
        if (it != block_iterative_pc_map.end()) {
            block_PC = it->second(pc);  // Create and store the block preconditioner
            block_PC->CreatePC();
            block_PC->initialize_solvers(pc_params.relTol_0, pc_params.absTol_0, 1.0e50, pc_params.mItr_0, 
                pc_params.prec_0, pc_params.relTol_1, pc_params.absTol_1, 1.0e50, pc_params.mItr_1, pc_params.prec_1);
        } else {
            throw std::runtime_error("Error: Unknown block-iterative preconditioner type:" + block_pc_type + ".");
        }
    }
    break;

    case PreconditionerType::PREC_PETSC_SCHUR:
        PCSetType(pc, PCFIELDSPLIT);
    break;

    case PreconditionerType::PREC_PETSC_RCS:
        psol[cEq].rcs = PETSC_TRUE;
        PetscPrintf(MPI_COMM_WORLD, "WARNING <PETSC_CREATE_LINEARSOLVER>: "
                                    "precondition the linear system with RCS first.\n"
                                    "WARNING <PETSC_CREATE_LINEARSOLVER>: "
                                    "This will NOT be overwritten by petsc_option.inp!\n");
    break;

    default:
        PetscPrintf(MPI_COMM_WORLD, "ERROR <PETSC_CREATE_LINEARSOLVER>: "
                                    "preconditioner type not supported through svFSI input file.\n"
                                    "ERROR <PETSC_CREATE_LINEARSOLVER>: "
                                    "More preconditioner options can be set through petsc_option.inp.\n");
    break;
    
    }

    /* Run time options */
    KSPSetFromOptions(psol[cEq].ksp);

    /* Set up PCFIELDSPLIT */
    PetscObjectTypeCompare((PetscObject)pc, PCFIELDSPLIT, &usefieldsplit);
    if (usefieldsplit)
    {
        if (phys == EquationType::phys_fluid || phys == EquationType::phys_ustruct || phys == EquationType::phys_stokes || phys ==EquationType::phys_FSI)
        {
            petsc_set_pcfieldsplit(dof, cEq);
        }
        else
        {
            PetscPrintf(MPI_COMM_WORLD, "///////////////////////////////////"
                                        "///////////////////////////////////////////////////////////////\n");
            PetscPrintf(MPI_COMM_WORLD, "WARNING <PETSC_CREATE_LINEARSOLVER>: "
                                        "PCFIELDSPLIT is hard-coded for ustruct/stokes/NS.\n");
            PetscPrintf(MPI_COMM_WORLD, "///////////////////////////////////"
                                        "///////////////////////////////////////////////////////////////\n");
        }
    }

    PetscLogStagePop();
}

/*
    Set up the linear system.
*/
void petsc_set_values(const PetscInt dof, const PetscInt iEq, const PetscReal *R,
                      const PetscReal *Val, const PetscReal *svFSI_DirBC, PetscReal** svFSI_lpBC)
{
    // PetscInt cEq = *iEq - 1;
    PetscInt cEq = iEq; // in Fortran, cEq = 1; in C++, cEq = 0;

    /* Set values in A &b, apply Dir and Lumped parameter BC */
    PetscLogStagePush(stages[3]);

    if (psol[cEq].block_iterative_pc)
    {
        petsc_set_splitvec(dof, cEq, R);
        petsc_set_splitmat(dof, cEq, Val);
        petsc_set_splitbc(cEq);
    } else
    {
        petsc_set_vec(dof, cEq, R);
        petsc_set_mat(dof, cEq, Val);
        petsc_set_bc(cEq, svFSI_DirBC, svFSI_lpBC);
    }
    
    PetscLogStagePop();

    /* Scale A and b if RCS preconditioner is activated. */
    PetscLogStagePush(stages[5]);
    if (psol[cEq].rcs)
    {
        petsc_pc_rcs(dof, cEq);
    }
    PetscLogStagePop();
}

/*
    Solve the linear system.
*/
PetscErrorCode petsc_solve(PetscReal *resNorm, PetscReal *initNorm, PetscReal *dB,
                 PetscReal *execTime, bool *converged, PetscInt *numIter,
                 PetscReal *R, const PetscInt maxIter, const PetscInt dof,
                 const PetscInt iEq)
{
    PetscReal *a, *array, *array_0, *array_1;
    PetscInt i, j, na;
    // PetscInt   cEq = *iEq - 1;
    PetscInt cEq = iEq; // in Fortran, cEq = 1; in C++, cEq = 0;
    PetscBool usepreonly;
    KSPType ksptype;
    Vec lx, lx_0, lx_1, res;
    KSPConvergedReason reason;
    PetscLogDouble ts, te;
    PetscBool usefieldsplit;

    PetscErrorCode ierr;

    PetscLogStagePush(stages[4]);
    na = maxIter;
    PetscMalloc1(na, &a);
    PetscTime(&ts);

    KSPSetOperators(psol[cEq].ksp, psol[cEq].A, psol[cEq].A);

    /* Set up block-iterative preconditioner */
    if (psol[cEq].block_iterative_pc && block_PC) {
        block_PC->setMatrix(psol[cEq].A);
    }

    PC pc;
    KSPGetPC(psol[cEq].ksp, &pc);
    PetscObjectTypeCompare((PetscObject)pc, PCFIELDSPLIT, &usefieldsplit);
    if (usefieldsplit) {
        PCFieldSplitSetType(pc, PC_COMPOSITE_SCHUR);
        PCFieldSplitSetSchurFactType(pc, PC_FIELDSPLIT_SCHUR_FACT_FULL);
        PCFieldSplitSetSchurPre(pc, PC_FIELDSPLIT_SCHUR_PRE_SELFP, NULL);
    }

    /* Calculate residual for direct solver. KSP uses preconditioned norm. */
    PetscObjectTypeCompare((PetscObject)psol[cEq].ksp, KSPPREONLY, &usepreonly);

    if (usepreonly)
    {
        VecNorm(psol[cEq].b, NORM_2, initNorm);
    }
    else
    {
        KSPSetResidualHistory(psol[cEq].ksp, a, na, PETSC_TRUE);
    }

    KSPSetUp(psol[cEq].ksp);
    KSPSolve(psol[cEq].ksp, psol[cEq].b, psol[cEq].b);

    /* Rescale solution for RCS preconditioner */
    if (psol[cEq].rcs)
    {
        VecPointwiseMult(psol[cEq].b, psol[cEq].b, psol[cEq].Dc);
    }

    /* Fill the ghost vertices with correct values. */

    Vec *svec; // It is used to point to the nested vector subvectors.
    if (psol[cEq].block_iterative_pc)
    {
        VecNestGetSubVecs(psol[cEq].b, NULL, &svec);
        VecGhostUpdateBegin(svec[0], INSERT_VALUES, SCATTER_FORWARD);
        VecGhostUpdateEnd(svec[0], INSERT_VALUES, SCATTER_FORWARD);
        VecGhostUpdateBegin(svec[1], INSERT_VALUES, SCATTER_FORWARD);
        VecGhostUpdateEnd(svec[1], INSERT_VALUES, SCATTER_FORWARD);
    } else 
    {
        VecGhostUpdateBegin(psol[cEq].b, INSERT_VALUES, SCATTER_FORWARD);
        VecGhostUpdateEnd(psol[cEq].b, INSERT_VALUES, SCATTER_FORWARD);
    } 

    PetscTime(&te);

    /* Get convergence info. */
    if (usepreonly)
    {
        *resNorm = __DBL_EPSILON__;
    }
    else
    {
        KSPGetResidualHistory(psol[cEq].ksp, (const PetscReal **)&a, &na);
        *initNorm = a[0];
        *resNorm = a[na - 1];
    }
    KSPGetIterationNumber(psol[cEq].ksp, numIter);
    KSPGetConvergedReason(psol[cEq].ksp, &reason);
    *converged = reason > 0 ? true : false;
    *dB = 10.0 * log(*resNorm / *initNorm);
    *execTime = te - ts;

    /* Export solution to svFSI. */
    if (psol[cEq].block_iterative_pc)
    {
        VecGhostGetLocalForm(svec[0], &lx_0);
        VecGhostGetLocalForm(svec[1], &lx_1);
        VecGetArray(lx_0, &array_0);
        VecGetArray(lx_1, &array_1);
        na = 0;
        for (i = 0; i < plhs.nNo; i++)
        {
            for (j = 0; j < dof-1; j++)
            {
                R[plhs.map[i] * (dof) + j] = array_0[na++];
            }
            R[plhs.map[i] * (dof) + dof-1] = array_1[i];
        }

        VecRestoreArray(lx_0, &array_0);
        VecRestoreArray(lx_1, &array_1);
        VecGhostRestoreLocalForm(svec[0], &lx_0);
        VecGhostRestoreLocalForm(svec[1], &lx_1);
    }
    else 
    {
        VecGhostGetLocalForm(psol[cEq].b, &lx);
        VecGetArray(lx, &array);
        na = 0;
        for (i = 0; i < plhs.nNo; i++)
        {
            for (j = 0; j < dof; j++)
            {
                R[plhs.map[i] * (dof) + j] = array[na++];
            }
        }
        VecRestoreArray(lx, &array);
        VecGhostRestoreLocalForm(psol[cEq].b, &lx);
    }

    PetscFree(a);
    PetscLogStagePop();
}

/*
    Clean up all petsc data.
*/
void petsc_destroy_all(const PetscInt nEq)
{
    if (!psol == NULL)
    {
        PetscInt cEq;
        PetscErrorCode ierr;

        if (!plhs.created)
        {
            PetscPrintf(MPI_COMM_WORLD, "ERROR <PETSC_DESTROY_ALL>: "
                                        "lhs is not created.\n");
            ierr = PETSC_ERR_ARG_WRONGSTATE;
            PETSCABORT(MPI_COMM_WORLD, ierr);
        }

        plhs.nNo = 0;
        plhs.mynNo = 0;
        plhs.created = PETSC_FALSE;

        PetscFree(plhs.map);
        PetscFree2(plhs.rowPtr, plhs.colPtr);
        PetscFree2(plhs.ltg, plhs.ghostltg);

        for (cEq = 0; cEq < nEq; cEq++)
        {
            if (!psol[cEq].created)
            {
                PetscPrintf(MPI_COMM_WORLD, "ERROR <PETSC_DESTROY_ALL>: "
                                            "solver %d is not created.\n",
                            cEq);
                ierr = PETSC_ERR_ARG_WRONGSTATE;
                PETSCABORT(MPI_COMM_WORLD, ierr);
            }

            psol[cEq].created = PETSC_FALSE;

            PetscFree(psol[cEq].lpPts);
            for (PetscInt faIn = 0; faIn < psol[cEq].nResFaces; ++faIn) {
                PetscFree(psol[cEq].lpBC_l[faIn]);
                PetscFree(psol[cEq].lpBC_g[faIn]);
            }
            PetscFree(psol[cEq].lpBC_l);
            PetscFree(psol[cEq].lpBC_g);

            psol[cEq].DirPts = 0;
            PetscFree(psol[cEq].DirBC);

            VecDestroy(&psol[cEq].b);
            VecDestroy(&psol[cEq].b_n[0]);
            VecDestroy(&psol[cEq].b_n[1]);
            MatDestroy(&psol[cEq].A);
            MatDestroy(&psol[cEq].A_mn[0]);
            MatDestroy(&psol[cEq].A_mn[1]);
            MatDestroy(&psol[cEq].A_mn[2]);
            MatDestroy(&psol[cEq].A_mn[3]);
            KSPDestroy(&psol[cEq].ksp);
            if (block_PC != nullptr) 
            {
                delete block_PC;  // Destroy the dynamically allocated object
                block_PC = nullptr;  // Avoid dangling pointer
            }


            if (psol[cEq].block_iterative_pc)
            {
                psol[cEq].block_iterative_pc = PETSC_FALSE;

                PetscFree(plhs.ghostltg_0);
                PetscFree(plhs.ghostltg_1);

                PetscFree(psol[cEq].lpPts_0);
                PetscFree(psol[cEq].lpPts_1);
                for (PetscInt faIn = 0; faIn < psol[cEq].nResFaces; ++faIn) {
                    PetscFree(psol[cEq].lpBC_l_0[faIn]);
                    PetscFree(psol[cEq].lpBC_g_0[faIn]);
                    PetscFree(psol[cEq].lpBC_l_1[faIn]);
                    PetscFree(psol[cEq].lpBC_g_1[faIn]);
                    PetscFree(psol[cEq].svFSI_lpBC_0[faIn]);
                    PetscFree(psol[cEq].svFSI_lpBC_1[faIn]);
                }
                PetscFree(psol[cEq].lpBC_l_0); PetscFree(psol[cEq].lpBC_g_0);
                PetscFree(psol[cEq].lpBC_l_1); PetscFree(psol[cEq].lpBC_g_1);
                PetscFree(psol[cEq].svFSI_lpBC_0); 
                PetscFree(psol[cEq].svFSI_lpBC_1);
                psol[cEq].nResFaces = 0;
                psol[cEq].DirPts_0 = 0;
                psol[cEq].DirPts_1 = 0;
                PetscFree(psol[cEq].DirBC_0); PetscFree(psol[cEq].svFSI_DirBC_0);
                PetscFree(psol[cEq].DirBC_1); PetscFree(psol[cEq].svFSI_DirBC_1);
            }

            if (psol[cEq].rcs)
            {
                psol[cEq].rcs = PETSC_FALSE;
                VecDestroy(&psol[cEq].Dr);
                VecDestroy(&psol[cEq].Dc);
            }
        }
        PetscFree(psol);

        PetscFinalize();
    }
}

/*
    Creating PETSc lhs data structure with svFSI info.
*/
PetscErrorCode petsc_create_lhs(const PetscInt nNo, const PetscInt mynNo, const PetscInt nnz,
                                const PetscInt *svFSI_ltg, const PetscInt *svFSI_map,
                                const PetscInt *svFSI_rowPtr, const PetscInt *svFSI_colPtr)
{
    PetscInt i, j;
    PetscErrorCode ierr;
    PetscInt *local2global, *local2local; /* local copy of svFSI ltg and map */
    PetscInt *local_ltg;                  /* local to global mapping of all vertices on current proc.*/
    PetscInt *owned_ltg;                  /* local to global mapping of owned vertices */
    PetscInt *ghost_ltg;                  /* local to global mapping of ghost vertices */
    PetscInt rstart;                      /* starting index of PETSc ordering for a processor */
    AO ao;                                /* Application Ordering object */
    PetscInt *pordering;                  /* PETSc ordering */
    PetscInt ghostnNo;                    /* number of ghost vertices */

    PetscFunctionBeginUser;

    /* In cases with remeshing, lhs needs to be regenerated. */
    if (plhs.created)
    {
        PetscPrintf(MPI_COMM_WORLD, "ERROR <PETSC_DESTROY_ALL>: \
                lhs is already created.");
        ierr = PETSC_ERR_ARG_WRONGSTATE;
        PETSCABORT(MPI_COMM_WORLD, ierr);
    }

    plhs.nNo = nNo;
    plhs.mynNo = mynNo;
    plhs.created = PETSC_TRUE;

    /* Fortran index to C index (NOT apply for svFSIplus) */
    PetscCall(PetscMalloc2(nNo, &local2global, nNo, &local2local));
    for (i = 0; i < nNo; i++)
    {
        // local2global[i] = svFSI_ltg[i] - 1;
        // local2local[i]  = svFSI_map[i] - 1;
        local2global[i] = svFSI_ltg[i];
        local2local[i] = svFSI_map[i];
    }

    /* Create local mapping, map[O2] = O1 */
    PetscCall(PetscMalloc1(nNo, &plhs.map));
    for (i = 0; i < nNo; i++)
    {
        plhs.map[local2local[i]] = i;
    }

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        Create global-to-global mapping using AO:
        - Global order 1 is from svFSI (ltg, i.e. O1).
        - Global order 2 is for PETSc (PETSc ordering). It is:
            |---- Proc 0-------|   |----------- Proc 2 ------------|
            0 1 ...   mynNo(0)-1    mynNo(0) ... mynNo(0)+mynNo(1)-1

        - Note that global order 2 locally follows O2 ordering, i.e.
           lower rank vtx + current rank vtx
        - Vertices from higher rank are ghost vertices.
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    /* Remap svFSI ltg to svFSI lhs%map order (O2) */
    PetscCall(PetscMalloc2(mynNo, &owned_ltg, nNo, &local_ltg));
    for (i = 0; i < nNo; i++)
    {
        j = local2local[i];
        local_ltg[j] = local2global[i];
    }
    for (i = 0; i < mynNo; i++)
        owned_ltg[i] = local_ltg[i];
    ghostnNo = nNo - mynNo;
    PetscCall(PetscMalloc1(ghostnNo, &ghost_ltg));
    for (i = 0; i < ghostnNo; i++)
        ghost_ltg[i] = local_ltg[i + mynNo];

    /* Create AO object between svFSI ltg and PETSc ordering */
    PetscCallMPI(MPI_Scan(&mynNo, &rstart, 1, MPIU_INT, MPI_SUM, MPI_COMM_WORLD));
    rstart -= mynNo;
    PetscCall(PetscMalloc1(mynNo, &pordering));
    for (i = 0; i < mynNo; i++)
        pordering[i] = rstart + i;
    PetscCall(AOCreateBasic(MPI_COMM_WORLD, mynNo, owned_ltg, pordering, &ao));

    /*
        Now map the vertex id in natural ordering to PETSc ordering.
        Before AOApplicationToPetsc:
            local_ltg[i] = natural id, i = 0,..., nNo-1
        After AOApplicationToPetsc:
            local_ltg[i] = PETSc id, i = 0,..., nNo-1
    */
    PetscCall(AOApplicationToPetsc(ao, nNo, local_ltg));
    PetscCall(AOApplicationToPetsc(ao, ghostnNo, ghost_ltg));
    PetscCall(AODestroy(&ao));

    PetscCall(PetscMalloc2(nNo, &plhs.ltg, ghostnNo, &plhs.ghostltg));
    for (i = 0; i < nNo; i++)
        plhs.ltg[i] = local_ltg[i];
    for (i = 0; i < ghostnNo; i++)
        plhs.ghostltg[i] = ghost_ltg[i];

    /* Adjacency info in PETSc lhs (i.e plhs.rowPtr and plhs.colPtr) is used to set values. */
    PetscCall(PetscMalloc2(2 * nNo, &plhs.rowPtr, nnz, &plhs.colPtr));
    for (i = 0; i < nNo; i++)
    {
        // plhs.rowPtr[i*2]   = svFSI_rowPtr[i*2] - 1;
        plhs.rowPtr[i * 2] = svFSI_rowPtr[i * 2];
        // plhs.rowPtr[i*2+1] = svFSI_rowPtr[i*2+1];
        plhs.rowPtr[i * 2 + 1] = svFSI_rowPtr[i * 2 + 1] + 1;
    }
    for (i = 0; i < nnz; i++)
    {
        // plhs.colPtr[i] = plhs.ltg[svFSI_colPtr[i] - 1];
        plhs.colPtr[i] = plhs.ltg[svFSI_colPtr[i]];
    }

    /* Deallocate memory */
    PetscCall(PetscFree2(owned_ltg, local_ltg));
    PetscCall(PetscFree2(local2global, local2local));
    PetscCall(PetscFree(ghost_ltg));
    PetscCall(PetscFree(pordering));

    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Creating PETSc data structure for Dirichlet and lumped parameter BC with svFSI info.
*/
PetscErrorCode petsc_create_bc(const PetscInt dof, const PetscInt cEq,
                               const PetscReal *svFSI_DirBC, PetscReal** svFSI_lpBC)
{
    PetscInt i, j, cc, ii;
    PetscInt *row1;
    PetscReal eps = 1.0e6 * __DBL_EPSILON__;

    PetscFunctionBeginUser;

    /* Find PETSc global index of dofs with Dirichlet BC */
    PetscCall(PetscMalloc1(plhs.mynNo * dof, &row1));
    cc = 0;
    for (i = 0; i < plhs.mynNo; i++)
    {
        ii = i * dof;
        for (j = 0; j < dof; j++)
        {
            if (((int)svFSI_DirBC[ii + j]) == 0)
            {
                row1[cc++] = plhs.ltg[i] * dof + j;
            }
        }
    }
    PetscCall(PetscMalloc1(cc, &psol[cEq].DirBC));
    psol[cEq].DirPts = cc;
    for (i = 0; i < cc; i++)
    {
        psol[cEq].DirBC[i] = row1[i];
    }

    /* Find O2 and PETSc index of dofs with lumped parameter BC */
    PetscCall(PetscMalloc1(psol[cEq].nResFaces, &psol[cEq].lpPts));
    for (int faIn = 0; faIn < psol[cEq].nResFaces; ++faIn)
    {
        cc = 0;
        for (int i = 0; i < plhs.mynNo; ++i)
        {
            int ii = i * dof;
            for (int j = 0; j < dof; ++j)
            {
                if (PetscAbsReal(svFSI_lpBC[faIn][ii + j]) > eps)
                {
                    cc++;
                }
            }
        }
        psol[cEq].lpPts[faIn] = cc;
    }

    PetscMalloc1(psol[cEq].nResFaces, &psol[cEq].lpBC_l);
    PetscMalloc1(psol[cEq].nResFaces, &psol[cEq].lpBC_g);
    for (int faIn = 0; faIn < psol[cEq].nResFaces; ++faIn)
    {
        PetscMalloc1(psol[cEq].lpPts[faIn], &psol[cEq].lpBC_l[faIn]); 
        PetscMalloc1(psol[cEq].lpPts[faIn], &psol[cEq].lpBC_g[faIn]);
    }

    for (int faIn = 0; faIn < psol[cEq].nResFaces; ++faIn)
    {
        cc = 0;
        for (int i = 0; i < plhs.mynNo; ++i)
        {
            int ii = i * dof;
            for (int j = 0; j < dof; ++j)
            {
                if (PetscAbsReal(svFSI_lpBC[faIn][ii + j]) > eps)
                {
                    psol[cEq].lpBC_l[faIn][cc] = ii + j;
                    psol[cEq].lpBC_g[faIn][cc] = plhs.ltg[i] * dof + j;
                    cc++;
                }
            }
        }
    }

    PetscCall(PetscFree(row1));

    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Creating split PETSc data structure for Dirichlet and lumped parameter BC with svFSI info.
*/
PetscErrorCode petsc_create_splitbc(const PetscInt dof, const PetscInt cEq,
                               const PetscReal *svFSI_DirBC, PetscReal **svFSI_lpBC)
{
    PetscInt i, j, cc, dd, ii, nvec, faIn;
    PetscInt *row1_0, *row1_1, *row2_0, *row2_1;
    PetscInt local_size_0, local_size_1;
    PetscReal eps = 1.0e6 * __DBL_EPSILON__;

    PetscFunctionBeginUser;

    local_size_0 = plhs.mynNo * (dof - 1); 
    local_size_1 = plhs.mynNo;

    PetscCall(PetscMalloc1(local_size_0, &psol[cEq].svFSI_DirBC_0));
    PetscCall(PetscMalloc1(local_size_1, &psol[cEq].svFSI_DirBC_1));
    PetscCall(PetscMalloc1(psol[cEq].nResFaces, &psol[cEq].svFSI_lpBC_0));
    PetscCall(PetscMalloc1(psol[cEq].nResFaces, &psol[cEq].svFSI_lpBC_1));

    /* Find PETSc global index of dofs with Dirichlet BC */
    PetscCall(PetscMalloc1(plhs.mynNo * (dof-1), &row1_0));
    PetscCall(PetscMalloc1(plhs.mynNo, &row1_1));
    
    for (i = 0; i < plhs.mynNo; i++)
    {
        ii = i * dof;
        for (j=0; j< dof-1; j++)
        {
            psol[cEq].svFSI_DirBC_0[i * (dof - 1) + j] = svFSI_DirBC[ii+j];
        }
        psol[cEq].svFSI_DirBC_1[i] = svFSI_DirBC[ii+(dof-1)];
    }

    for (faIn = 0; faIn < psol[cEq].nResFaces; ++faIn)
    {
        PetscCall(PetscMalloc1(local_size_0, &psol[cEq].svFSI_lpBC_0[faIn]));
        PetscCall(PetscMalloc1(local_size_1, &psol[cEq].svFSI_lpBC_1[faIn]));
        for (i = 0; i < plhs.mynNo; i++)
        {  
            ii = i * dof;
            for (j=0; j< dof-1; j++)
            {
                psol[cEq].svFSI_lpBC_0[faIn][i * (dof - 1) + j] = svFSI_lpBC[faIn][ii+j];
            }
            psol[cEq].svFSI_lpBC_1[faIn][i] = svFSI_lpBC[faIn][ii+(dof-1)];
        }               
    }

    cc = 0;
    dd = 0;
    for (i = 0; i < plhs.mynNo; i++)
    {
        ii = i * (dof - 1);
        for (j = 0; j < (dof - 1); j++)
        {
            if (((int)psol[cEq].svFSI_DirBC_0[ii + j]) == 0)
            {
                row1_0[cc++] = plhs.ltg[i] * (dof - 1) + j; 
            }
        }
    }

    for (i=0; i< plhs.mynNo; i++)
    {
        if (((int)psol[cEq].svFSI_DirBC_1[i]) == 0)
        {
            row1_1[dd++] = plhs.ltg[i]; 
        }
    }

    PetscCall(PetscMalloc1(cc, &psol[cEq].DirBC_0));
    PetscCall(PetscMalloc1(dd, &psol[cEq].DirBC_1));
    psol[cEq].DirPts_0 = cc;
    psol[cEq].DirPts_1 = dd;

    for (i = 0; i < cc; i++)
    {
        psol[cEq].DirBC_0[i] = row1_0[i];
    }
    for (i = 0; i < dd; i++)
    {
        psol[cEq].DirBC_1[i] = row1_1[i];
    }

    /* Find O2 and PETSc index of dofs with lumped parameter BC */
    PetscCall(PetscMalloc1(psol[cEq].nResFaces, &psol[cEq].lpPts_0));
    PetscCall(PetscMalloc1(psol[cEq].nResFaces, &psol[cEq].lpPts_1));
    for (faIn = 0; faIn < psol[cEq].nResFaces; ++faIn) 
    {
        cc = 0;
        dd = 0;
        for (i = 0; i < plhs.mynNo; i++)
        {
            ii = i * (dof - 1);
            for (j = 0; j < (dof - 1); j++)
            {
                if (PetscAbsReal(psol[cEq].svFSI_lpBC_0[faIn][ii + j]) > eps)
                {
                    cc++;
                }
            }
            if (PetscAbsReal(psol[cEq].svFSI_lpBC_1[faIn][i]) > eps)
            {
                dd++;
            }
        }
        psol[cEq].lpPts_0[faIn] = cc;
        psol[cEq].lpPts_1[faIn] = dd;
    }

    PetscCall(PetscMalloc2(psol[cEq].nResFaces, &psol[cEq].lpBC_l_0, psol[cEq].nResFaces, &psol[cEq].lpBC_g_0));
    PetscCall(PetscMalloc2(psol[cEq].nResFaces, &psol[cEq].lpBC_l_1, psol[cEq].nResFaces, &psol[cEq].lpBC_g_1));
    for (int faIn = 0; faIn < psol[cEq].nResFaces; ++faIn)
    {
        PetscCall(PetscMalloc2(psol[cEq].lpPts_0[faIn], &psol[cEq].lpBC_l_0[faIn], psol[cEq].lpPts_0[faIn], &psol[cEq].lpBC_g_0[faIn]));
        PetscCall(PetscMalloc2(psol[cEq].lpPts_1[faIn], &psol[cEq].lpBC_l_1[faIn], psol[cEq].lpPts_1[faIn], &psol[cEq].lpBC_g_1[faIn]));
    }
    for (faIn = 0; faIn < psol[cEq].nResFaces; ++faIn) 
    {
        cc = 0;
        dd = 0;
        for (i = 0; i < plhs.mynNo; i++)
        {
            ii = i * (dof - 1);
            for (j = 0; j < (dof - 1); j++)
            {
                if (PetscAbsReal(psol[cEq].svFSI_lpBC_0[faIn][ii + j]) > eps)
                {
                    psol[cEq].lpBC_l_0[faIn][cc] = ii + j;
                    psol[cEq].lpBC_g_0[faIn][cc] = plhs.ltg[i] * (dof - 1) + j;
                    cc++;
                }
            }
            if (PetscAbsReal(psol[cEq].svFSI_lpBC_1[faIn][i]) > eps)
            {
                psol[cEq].lpBC_l_1[faIn][dd] = i;
                psol[cEq].lpBC_g_1[faIn][dd] = plhs.ltg[i];
                dd++;
            }
        }
    }

    PetscCall(PetscFree(row1_0));
    PetscCall(PetscFree(row1_1));
    
    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Create and preallocate parallel PETSC vector and matrix data structure.
*/
PetscErrorCode petsc_create_vecmat(const PetscInt dof, const PetscInt cEq, const PetscInt nEq)
{
    PetscInt i, j, is, ie, row, col;
    Mat preallocator;
    PetscReal *value;
    PC pc;
    PetscBool usefieldsplit, useamg;

    PetscFunctionBeginUser;

    /* Create vector data structures */
    PetscCall(VecCreateGhostBlock(MPI_COMM_WORLD, dof, plhs.mynNo * dof, PETSC_DECIDE, plhs.nNo - plhs.mynNo, plhs.ghostltg, &psol[cEq].b));
    if (nEq > 1)
        PetscCall(VecSetOptionsPrefix(psol[cEq].b, psol[cEq].pre));
    PetscCall(VecSetFromOptions(psol[cEq].b));

    /*
        Preallocate psol.A with the help of MATPREALLOCATOR.
        Internally MatPreallocatorPreallocate() will call MatSetOption(A, MAT_NEW_NONZERO_ALLOCATION_ERR, PETSC_TRUE);
    */
    PetscCall(MatCreate(MPI_COMM_WORLD, &preallocator));
    PetscCall(MatSetType(preallocator, MATPREALLOCATOR));
    PetscCall(MatSetSizes(preallocator, plhs.mynNo * dof, plhs.mynNo * dof, PETSC_DECIDE, PETSC_DECIDE));
    PetscCall(MatSetBlockSize(preallocator, dof));
    PetscCall(MatSetUp(preallocator));
    PetscCall(PetscMalloc1(dof * dof, &value));
    for (i = 0; i < dof * dof; i++)
        value[i] = 0.0;
    /* Internal points */
    for (i = 0; i < plhs.nNo; i++)
    {
        is = plhs.rowPtr[i * 2];
        ie = plhs.rowPtr[i * 2 + 1];
        row = plhs.ltg[i];
        for (j = is; j < ie; j++)
        {
            col = plhs.colPtr[j];
            PetscCall(MatSetValuesBlocked(preallocator, 1, &row, 1, &col, value, INSERT_VALUES));
        }
    }
    /* Points with lumped parameter BC */
    for (int faIn = 0; faIn < psol[cEq].nResFaces; faIn++)
    {
        for (i = 0; i < psol[cEq].lpPts[faIn]; i++)
        {
            row = psol[cEq].lpBC_g[faIn][i];
            for (j = 0; j < psol[cEq].lpPts[faIn]; j++)
            {
                col = psol[cEq].lpBC_g[faIn][j];
                PetscCall(MatSetValue(preallocator, row, col, 0.0, INSERT_VALUES));
            }
        }
    }
    PetscCall(MatAssemblyBegin(preallocator, MAT_FINAL_ASSEMBLY));
    PetscCall(MatAssemblyEnd(preallocator, MAT_FINAL_ASSEMBLY));

    /* Create and preallocate matrix structure */
    KSPGetPC(psol[cEq].ksp, &pc);
    PetscObjectTypeCompare((PetscObject)pc, PCFIELDSPLIT, &usefieldsplit); /* Fieldsplit only supports MATAIJ */
    PetscObjectTypeCompare((PetscObject)pc, PCGAMG, &useamg);              /* GAMG only supports MATAIJ */
    PetscCall(MatCreate(MPI_COMM_WORLD, &psol[cEq].A));
    if (dof > 1 && !usefieldsplit && !useamg && !psol[cEq].block_iterative_pc)
    {
        PetscCall(MatSetType(psol[cEq].A, MATBAIJ));
    }
    else
    {
        PetscCall(MatSetType(psol[cEq].A, MATAIJ));
    }
    if (nEq > 1)
        PetscCall(MatSetOptionsPrefix(psol[cEq].A, psol[cEq].pre));
    PetscCall(MatSetFromOptions(psol[cEq].A));
    PetscCall(MatSetSizes(psol[cEq].A, plhs.mynNo * dof, plhs.mynNo * dof, PETSC_DECIDE, PETSC_DECIDE));
    PetscCall(MatSetBlockSize(psol[cEq].A, dof));
    PetscCall(MatPreallocatorPreallocate(preallocator, PETSC_TRUE, psol[cEq].A));
    PetscCall(MatSetOption(psol[cEq].A, MAT_NEW_NONZERO_LOCATION_ERR, PETSC_TRUE));
    PetscCall(MatSetOption(psol[cEq].A, MAT_NEW_NONZERO_LOCATIONS, PETSC_FALSE));

    /* Create vector structure for RCS preconditioner */
    if (psol[cEq].rcs)
    {
        PetscCall(VecDuplicate(psol[cEq].b, &psol[cEq].Dr));
        PetscCall(VecDuplicate(psol[cEq].b, &psol[cEq].Dc));
    }

    PetscCall(PetscFree(value));
    PetscCall(MatDestroy(&preallocator));

    PetscFunctionReturn(PETSC_SUCCESS);
}

// Create and preallocate parallel split PETSC vector and matrix data structure.
PetscErrorCode petsc_create_splitvecmat(const PetscInt dof, const PetscInt cEq, const PetscInt nEq)
{
    PetscInt i, ii, j, jj, is, ie, row, col, nghost;
    Mat preallocator_00, preallocator_01, preallocator_10, preallocator_11;
    PetscScalar value;
    PC pc;
    PetscBool usefieldsplit, useamg;

    PetscErrorCode ierr;

    PetscFunctionBeginUser;

    // Creating ghost structure for split vectors
    nghost = plhs.nNo - plhs.mynNo; // number of ghost nodes
    PetscCall(PetscMalloc1(nghost * (dof-1), &plhs.ghostltg_0));
    PetscCall(PetscMalloc1(nghost, &plhs.ghostltg_1));

    // Create ghost nodes local to global mapping
    for (i = 0; i < nghost; i++)
    {
        for (j = 0; j < dof-1; j++)
        {
            plhs.ghostltg_0[i*(dof-1)+j] = plhs.ghostltg[i] * (dof-1) + j;
        }
        plhs.ghostltg_1[i] = plhs.ghostltg[i];
    } 

    // Allocate the sub-vectors
    PetscCall(VecCreateGhost(MPI_COMM_WORLD, plhs.mynNo * (dof-1), PETSC_DETERMINE, nghost * (dof-1) , plhs.ghostltg_0, &psol[cEq].b_n[0]));
    PetscCall(VecCreateGhost(MPI_COMM_WORLD, plhs.mynNo, PETSC_DETERMINE, nghost, plhs.ghostltg_1, &psol[cEq].b_n[1]));
    PetscCall(VecSetFromOptions(psol[cEq].b_n[0]));
    PetscCall(VecSetFromOptions(psol[cEq].b_n[1]));

    /*
        Preallocate psol.A_mn[] with the help of MATPREALLOCATOR.
        We preallocate 4 submatrices: 
        [ A_00  A_01 ]
        [ A_10  A_11 ]
    */
    MatCreatePreallocator(plhs.mynNo * (dof-1), plhs.mynNo * (dof-1), &preallocator_00);
    MatCreatePreallocator(plhs.mynNo * (dof-1), plhs.mynNo, &preallocator_01);
    MatCreatePreallocator(plhs.mynNo, plhs.mynNo * (dof-1), &preallocator_10);
    MatCreatePreallocator(plhs.mynNo, plhs.mynNo, &preallocator_11);

    value = 0.0;
    for (i = 0; i < plhs.nNo; i++)
    {
        is = plhs.rowPtr[i * 2];
        ie = plhs.rowPtr[i * 2 + 1];
        ii = plhs.ltg[i];
        for (j = is; j < ie; j++)
        {
            jj = plhs.colPtr[j];
            for (int k = 0; k < dof - 1; k++)
            {
                row = ii * (dof - 1) + k;
                for (int l = 0; l < dof-1; l++)
                {
                    col = jj * (dof - 1) + l;
                    PetscCall(MatSetValue(preallocator_00, row, col, value, INSERT_VALUES));
                }
                col = jj;
                PetscCall(MatSetValue(preallocator_01, row, col, value, INSERT_VALUES));
            }
            row = ii;
            for (int k = 0; k < dof-1; k++)
            {
                col = jj * (dof - 1) + k;
                PetscCall(MatSetValue(preallocator_10, row, col, value, INSERT_VALUES));
                
            }
            col = jj;
            PetscCall(MatSetValue(preallocator_11, row, col, value, INSERT_VALUES));
        }
    }

    /* Points with lumped parameter BC */
    for (int faIn = 0; faIn < psol[cEq].nResFaces; ++faIn)
    {
        for (i = 0; i < psol[cEq].lpPts_0[faIn]; i++)
        {
            row = psol[cEq].lpBC_g_0[faIn][i];
            for (j = 0; j < psol[cEq].lpPts_0[faIn]; j++)
            {
                col = psol[cEq].lpBC_g_0[faIn][j];
                PetscCall(MatSetValue(preallocator_00, row, col, 0.0, INSERT_VALUES));
            }
            for (j = 0; j < psol[cEq].lpPts_1[faIn]; j++)
            {
                col = psol[cEq].lpBC_g_1[faIn][j];
                PetscCall(MatSetValue(preallocator_01, row, col, 0.0, INSERT_VALUES));
            }
        }
        for (i = 0; i < psol[cEq].lpPts_1[faIn]; i++)
        {
            row = psol[cEq].lpBC_g_1[faIn][i];
            for (j = 0; j < psol[cEq].lpPts_0[faIn]; j++)
            {
                col = psol[cEq].lpBC_g_0[faIn][j];
                PetscCall(MatSetValue(preallocator_10, row, col, 0.0, INSERT_VALUES));
            }
            for (j = 0; j < psol[cEq].lpPts_1[faIn]; j++)
            {
                col = psol[cEq].lpBC_g_1[faIn][j];
                PetscCall(MatSetValue(preallocator_11, row, col, 0.0, INSERT_VALUES));
            }
        }
    }

    PetscCall(MatAssemblyBegin(preallocator_00, MAT_FINAL_ASSEMBLY)); 
    PetscCall(MatAssemblyEnd(preallocator_00, MAT_FINAL_ASSEMBLY));
    PetscCall(MatAssemblyBegin(preallocator_01, MAT_FINAL_ASSEMBLY));
    PetscCall(MatAssemblyEnd(preallocator_01, MAT_FINAL_ASSEMBLY));
    PetscCall(MatAssemblyBegin(preallocator_10, MAT_FINAL_ASSEMBLY)); 
    PetscCall(MatAssemblyEnd(preallocator_10, MAT_FINAL_ASSEMBLY));
    PetscCall(MatAssemblyBegin(preallocator_11, MAT_FINAL_ASSEMBLY)); 
    PetscCall(MatAssemblyEnd(preallocator_11, MAT_FINAL_ASSEMBLY));

    MatCreatePreallocSubMat(plhs.mynNo * (dof - 1), plhs.mynNo * (dof - 1), &psol[cEq].A_mn[0], &preallocator_00);
    MatCreatePreallocSubMat(plhs.mynNo * (dof - 1), plhs.mynNo, &psol[cEq].A_mn[1], &preallocator_01);
    MatCreatePreallocSubMat(plhs.mynNo, plhs.mynNo * (dof - 1), &psol[cEq].A_mn[2], &preallocator_10);
    MatCreatePreallocSubMat(plhs.mynNo, plhs.mynNo, &psol[cEq].A_mn[3], &preallocator_11);
    
    // Clean up
    PetscCall(MatDestroy(&preallocator_00)); 
    PetscCall(MatDestroy(&preallocator_01)); 
    PetscCall(MatDestroy(&preallocator_10)); 
    PetscCall(MatDestroy(&preallocator_11)); 

    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Set values to the rhs vector.
    R is the rhs from svFSI in O1 order.
*/
PetscErrorCode petsc_set_vec(const PetscInt dof, const PetscInt cEq, const PetscReal *R)
{
    PetscInt indx, i;
    PetscInt *row;
    const PetscReal *value;

    PetscFunctionBeginUser;

    /* Set the rhs vector using global index. */
    PetscCall(VecZeroEntries(psol[cEq].b));

    for (i = 0; i < plhs.mynNo; i++)
    {
        row = plhs.ltg + i;
        indx = plhs.map[i];
        value = R + indx * dof;
        PetscCall(VecSetValuesBlocked(psol[cEq].b, 1, row, value, INSERT_VALUES));
    }
    PetscCall(VecAssemblyBegin(psol[cEq].b));
    PetscCall(VecAssemblyEnd(psol[cEq].b));

    /* Fill the ghost vertices with correct values. */
    PetscCall(VecGhostUpdateBegin(psol[cEq].b, INSERT_VALUES, SCATTER_FORWARD));
    PetscCall(VecGhostUpdateEnd(psol[cEq].b, INSERT_VALUES, SCATTER_FORWARD));

    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Set values to the subvectors b_n[].
    R is the rhs from svFSI in O1 order.
*/
PetscErrorCode petsc_set_splitvec(const PetscInt dof, const PetscInt cEq, const PetscReal *R)
{
    PetscInt indx, i, ii;
    PetscInt row;
    PetscReal value;

    PetscErrorCode ierr;

    PetscFunctionBeginUser;

    // b_n[0]
    PetscCall(VecZeroEntries(psol[cEq].b_n[0]));
    for (i = 0; i < plhs.mynNo; i++)
    {
        ii = plhs.ltg[i];
        indx = plhs.map[i];
        for (int k = 0; k < dof-1; k++)
        {
            row = ii * (dof-1) + k;
            value = R[indx * dof + k];
            PetscCall(VecSetValue(psol[cEq].b_n[0], row, value, INSERT_VALUES));
        }
    }

    PetscCall(VecAssemblyBegin(psol[cEq].b_n[0]));
    PetscCall(VecAssemblyEnd(psol[cEq].b_n[0]));

    PetscCall(VecGhostUpdateBegin(psol[cEq].b_n[0], INSERT_VALUES, SCATTER_FORWARD));
    PetscCall(VecGhostUpdateEnd(psol[cEq].b_n[0], INSERT_VALUES, SCATTER_FORWARD));

    // b_n[1]
    PetscCall(VecZeroEntries(psol[cEq].b_n[1]));
    for (i = 0; i < plhs.mynNo; i++)
    {
        row = plhs.ltg[i];
        indx = plhs.map[i];
        value = R[indx * dof + dof - 1];
        PetscCall(VecSetValue(psol[cEq].b_n[1], row, value, INSERT_VALUES));
    }
    PetscCall(VecAssemblyBegin(psol[cEq].b_n[1]));
    PetscCall(VecAssemblyEnd(psol[cEq].b_n[1]));

    PetscCall(VecGhostUpdateBegin(psol[cEq].b_n[1], INSERT_VALUES, SCATTER_FORWARD));
    PetscCall(VecGhostUpdateEnd(psol[cEq].b_n[1], INSERT_VALUES, SCATTER_FORWARD));
    
    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Set values to the matrix.
*/
PetscErrorCode petsc_set_mat(const PetscInt dof, const PetscInt cEq, const PetscReal *Val)
{
    PetscInt i, j, is, ie;
    PetscInt *col, *row;
    const PetscScalar *value;

    PetscFunctionBeginUser;

    PetscCall(MatZeroEntries(psol[cEq].A));
    for (i = 0; i < plhs.nNo; i++)
    {
        is = plhs.rowPtr[i * 2];
        ie = plhs.rowPtr[i * 2 + 1];
        row = plhs.ltg + i;
        for (j = is; j < ie; j++)
        {
            value = Val + j * dof * dof;
            col = plhs.colPtr + j;
            PetscCall(MatSetValuesBlocked(psol[cEq].A, 1, row, 1, col, value, ADD_VALUES));
        }
    }
    PetscCall(MatAssemblyBegin(psol[cEq].A, MAT_FLUSH_ASSEMBLY));
    PetscCall(MatAssemblyEnd(psol[cEq].A, MAT_FLUSH_ASSEMBLY));

    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Set values to the submatrices A_mn[].
*/
PetscErrorCode petsc_set_splitmat(const PetscInt dof, const PetscInt cEq, const PetscReal *Val)
{
    PetscInt i, ii, j, jj, is, ie;
    PetscInt col, row;
    PetscScalar value;

    PetscErrorCode ierr;

    PetscFunctionBeginUser;

    /* Initializing submatrices */
    PetscCall(MatZeroEntries(psol[cEq].A_mn[0]));
    PetscCall(MatZeroEntries(psol[cEq].A_mn[1]));
    PetscCall(MatZeroEntries(psol[cEq].A_mn[2]));
    PetscCall(MatZeroEntries(psol[cEq].A_mn[3]));

    for (i = 0; i < plhs.nNo; i++)
    {
        is = plhs.rowPtr[i * 2];
        ie = plhs.rowPtr[i * 2 + 1];
        ii = plhs.ltg[i];
        for (j = is; j < ie; j++)
        {
            jj = plhs.colPtr[j];
            for (int k = 0; k < dof-1; k++)
            {
                row = ii * (dof - 1) + k;
                for (int l = 0; l < dof-1; l++)
                {
                    col = jj * (dof - 1) + l;
                    value = Val[(j * dof * dof) + (k * dof) + l];
                    PetscCall(MatSetValue(psol[cEq].A_mn[0], row, col, value, ADD_VALUES));
                }
                col = jj;
                value = Val[(j * dof * dof) + (k * dof) + dof - 1];
                PetscCall(MatSetValue(psol[cEq].A_mn[1], row, col, value, ADD_VALUES));
            }
            row = ii;
            for (int k = 0; k < dof-1; k++)
            {
                col = jj * (dof - 1) + k;
                value = Val[(j * dof * dof) + (dof - 1) * dof + k];
                PetscCall(MatSetValue(psol[cEq].A_mn[2], row, col, value, ADD_VALUES));
            }
            col = jj;
            value = Val[(j * dof * dof) + (dof - 1) * dof + dof - 1];
            PetscCall(MatSetValue(psol[cEq].A_mn[3], row, col, value, ADD_VALUES));
        }
    }

    PetscCall(MatAssemblyBegin(psol[cEq].A_mn[0], MAT_FLUSH_ASSEMBLY)); 
    PetscCall(MatAssemblyEnd(psol[cEq].A_mn[0], MAT_FLUSH_ASSEMBLY));
    PetscCall(MatAssemblyBegin(psol[cEq].A_mn[1], MAT_FLUSH_ASSEMBLY)); 
    PetscCall(MatAssemblyEnd(psol[cEq].A_mn[1], MAT_FLUSH_ASSEMBLY));
    PetscCall(MatAssemblyBegin(psol[cEq].A_mn[2], MAT_FLUSH_ASSEMBLY)); 
    PetscCall(MatAssemblyEnd(psol[cEq].A_mn[2], MAT_FLUSH_ASSEMBLY));
    PetscCall(MatAssemblyBegin(psol[cEq].A_mn[3], MAT_FLUSH_ASSEMBLY)); 
    PetscCall(MatAssemblyEnd(psol[cEq].A_mn[3], MAT_FLUSH_ASSEMBLY));

    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Set up Dirichlet BC and resistance BC.
*/
PetscErrorCode petsc_set_bc(const PetscInt cEq, const PetscReal *DirBC, PetscReal** lpBC)
{
    Vec x;
    PetscInt i, j, ii, jj, row, col;
    PetscReal value;

    PetscFunctionBeginUser;

    /* Apply lumped parameter BC by augmenting the matrix A. */
    for (int faIn = 0; faIn < psol[cEq].nResFaces; faIn++)
    {
        for (i = 0; i < psol[cEq].lpPts[faIn]; i++)
        {
            ii = psol[cEq].lpBC_l[faIn][i];
            row = psol[cEq].lpBC_g[faIn][i];
            for (j = 0; j < psol[cEq].lpPts[faIn]; j++)
            {
                jj = psol[cEq].lpBC_l[faIn][j];
                col = psol[cEq].lpBC_g[faIn][j];
                value = lpBC[faIn][ii] * lpBC[faIn][jj];
                PetscCall(MatSetValue(psol[cEq].A, row, col, value, ADD_VALUES));
            }
        }
    }

    PetscCall(MatAssemblyBegin(psol[cEq].A, MAT_FINAL_ASSEMBLY));
    PetscCall(MatAssemblyEnd(psol[cEq].A, MAT_FINAL_ASSEMBLY));    
    /*
        Apply Dirichlet BC by resetting matrix A and rhs b.
        Since the BC remains the same, the matrix will retain the same nonzero structure
    */
    PetscCall(VecDuplicate(psol[cEq].b, &x));
    PetscCall(VecPlaceArray(x, DirBC));
    PetscCall(MatZeroRowsColumns(psol[cEq].A, psol[cEq].DirPts, psol[cEq].DirBC, 1.0, x, psol[cEq].b));

    PetscCall(VecDestroy(&x));
    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Set up Dirichlet BC and resistance BC for submatrices A_mn[] and subvectors b_n[].
*/
PetscErrorCode petsc_set_splitbc(const PetscInt cEq)
{
    Vec x;
    PetscInt i, j, ii, jj, row, col;
    PetscReal value;
    Mat transpose, newmat;

    PetscErrorCode ierr;

    PetscFunctionBeginUser;

    /* Points with lumped parameter BC */
    for (int faIn = 0; faIn < psol[cEq].nResFaces; faIn++)
    {
        for (i = 0; i < psol[cEq].lpPts_0[faIn]; i++)
        {
            ii = psol[cEq].lpBC_l_0[faIn][i];
            row = psol[cEq].lpBC_g_0[faIn][i];
            for (j = 0; j < psol[cEq].lpPts_0[faIn]; j++)
            {
                jj = psol[cEq].lpBC_l_0[faIn][j];
                col = psol[cEq].lpBC_g_0[faIn][j];
                value = psol[cEq].svFSI_lpBC_0[faIn][ii] * psol[cEq].svFSI_lpBC_0[faIn][jj];
                PetscCall(MatSetValue(psol[cEq].A_mn[0], row, col, value, ADD_VALUES));
            }
            for (j = 0; j < psol[cEq].lpPts_1[faIn]; j++)
            {
                jj = psol[cEq].lpBC_l_1[faIn][j];
                col = psol[cEq].lpBC_g_1[faIn][j];
                value = psol[cEq].svFSI_lpBC_0[faIn][ii] * psol[cEq].svFSI_lpBC_1[faIn][jj];
                PetscCall(MatSetValue(psol[cEq].A_mn[1], row, col, value, ADD_VALUES));
            }
        }
        for (i = 0; i < psol[cEq].lpPts_1[faIn]; i++)
        {
            ii = psol[cEq].lpBC_l_1[faIn][i];
            row = psol[cEq].lpBC_g_1[faIn][i];
            for (j = 0; j < psol[cEq].lpPts_0[faIn]; j++)
            {
                jj = psol[cEq].lpBC_l_0[faIn][j];
                col = psol[cEq].lpBC_g_0[faIn][j];
                value = psol[cEq].svFSI_lpBC_1[faIn][ii] * psol[cEq].svFSI_lpBC_0[faIn][jj];
                PetscCall(MatSetValue(psol[cEq].A_mn[2], row, col, value, ADD_VALUES));
            }
            for (j = 0; j < psol[cEq].lpPts_1[faIn]; j++)
            {
                jj = psol[cEq].lpBC_l_1[faIn][j];
                col = psol[cEq].lpBC_g_1[faIn][j];
                value = psol[cEq].svFSI_lpBC_1[faIn][ii] * psol[cEq].svFSI_lpBC_1[faIn][jj];
                PetscCall(MatSetValue(psol[cEq].A_mn[3], row, col, value, ADD_VALUES));
            }
        }
    }
    PetscCall(MatAssemblyBegin(psol[cEq].A_mn[0], MAT_FINAL_ASSEMBLY)); PetscCall(MatAssemblyEnd(psol[cEq].A_mn[0], MAT_FINAL_ASSEMBLY));
    PetscCall(MatAssemblyBegin(psol[cEq].A_mn[1], MAT_FINAL_ASSEMBLY)); PetscCall(MatAssemblyEnd(psol[cEq].A_mn[1], MAT_FINAL_ASSEMBLY));
    PetscCall(MatAssemblyBegin(psol[cEq].A_mn[2], MAT_FINAL_ASSEMBLY)); PetscCall(MatAssemblyEnd(psol[cEq].A_mn[2], MAT_FINAL_ASSEMBLY));
    PetscCall(MatAssemblyBegin(psol[cEq].A_mn[3], MAT_FINAL_ASSEMBLY)); PetscCall(MatAssemblyEnd(psol[cEq].A_mn[3], MAT_FINAL_ASSEMBLY));

    /*
        Apply Dirichlet BC by resetting submatrices A_mn and rhs b_n.
    */
    /* Apply Dirichlet BC to A_00 submatrix: zero-out rows and columns, set diag to 1 */
    PetscCall(VecDuplicate(psol[cEq].b_n[0], &x));
    PetscCall(VecPlaceArray(x, psol[cEq].svFSI_DirBC_0));
    PetscCall(MatZeroRowsColumns(psol[cEq].A_mn[0], psol[cEq].DirPts_0, psol[cEq].DirBC_0, 1.0, x, psol[cEq].b_n[0]));

    /* Apply Dirichlet BC to A_01 submatrix: zero-out rows */
    PetscCall(MatZeroRows(psol[cEq].A_mn[1], psol[cEq].DirPts_0, psol[cEq].DirBC_0, 0.0, NULL, NULL));
    
    /* Apply Dirichlet BC to A_10 submatrix: zero-out columns */
    PetscCall(MatTranspose(psol[cEq].A_mn[2], MAT_INITIAL_MATRIX, &transpose));
    PetscCall(MatZeroRows(transpose, psol[cEq].DirPts_0, psol[cEq].DirBC_0, 0.0, NULL, NULL));
    PetscCall(MatAssemblyBegin(transpose, MAT_FINAL_ASSEMBLY));
    PetscCall(MatAssemblyEnd(transpose, MAT_FINAL_ASSEMBLY));
    PetscCall(MatTranspose(transpose, MAT_INITIAL_MATRIX, &newmat));
    PetscCall(MatCopy(newmat, psol[cEq].A_mn[2], DIFFERENT_NONZERO_PATTERN));

    /* Apply Dirichlet BC to A_11 submatrix: zero-out rows and columns, set diag to 1 */
    PetscCall(VecDestroy(&x));
    PetscCall(VecDuplicate(psol[cEq].b_n[1], &x));
    PetscCall(VecPlaceArray(x, psol[cEq].svFSI_DirBC_1));
    PetscCall(MatZeroRowsColumns(psol[cEq].A_mn[3], psol[cEq].DirPts_1, psol[cEq].DirBC_1, 1.0, x, psol[cEq].b_n[1]));

    /* Assemble the nested matrix */
    PetscCall(MatCreateNest(MPI_COMM_WORLD, 2, NULL, 2, NULL, psol[cEq].A_mn, &psol[cEq].A));
    PetscCall(MatNestSetVecType(psol[cEq].A,VECNEST));
    PetscCall(VecCreateNest(MPI_COMM_WORLD, 2, NULL, psol[cEq].b_n, &psol[cEq].b));

    // Clean up
    PetscCall(MatDestroy(&transpose));
    PetscCall(MatDestroy(&newmat));
    PetscCall(VecDestroy(&x));
    
    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Set up PCFIELDSPLIT.
*/
PetscErrorCode petsc_set_pcfieldsplit(const PetscInt dof, const PetscInt cEq)
{
    IS isu, isp;
    PetscInt i, j, ii, jj;
    PetscInt *uindx, *pindx;
    PC pc;

    PetscFunctionBeginUser;

    /* Create index set for velocity and pressure block */
    PetscCall(PetscMalloc2((dof - 1) * plhs.mynNo, &uindx, plhs.mynNo, &pindx));
    for (i = 0; i < plhs.mynNo; i++)
    {
        ii = (dof - 1) * i;
        jj = dof * plhs.ltg[i];
        for (j = 0; j < dof - 1; j++)
        {
            uindx[ii + j] = jj + j;
        }
        pindx[i] = jj + dof - 1;
    }
    PetscCall(ISCreateGeneral(MPI_COMM_WORLD, (dof - 1) * plhs.mynNo, uindx, PETSC_COPY_VALUES, &isu));
    PetscCall(ISSetBlockSize(isu, dof - 1));
    PetscCall(ISSort(isu));
    PetscCall(ISCreateGeneral(MPI_COMM_WORLD, plhs.mynNo, pindx, PETSC_COPY_VALUES, &isp));
    PetscCall(ISSort(isp));

    /* Pass split information to PETSc. Velocity: block 0, pressure: block 1. */
    PetscCall(KSPGetPC(psol[cEq].ksp, &pc));
    PetscCall(PCFieldSplitSetBlockSize(pc, 2));
    PetscCall(PCFieldSplitSetIS(pc, "0", isu));
    PetscCall(PCFieldSplitSetIS(pc, "1", isp));

    PetscCall(ISDestroy(&isu));
    PetscCall(ISDestroy(&isp));
    PetscCall(PetscFree2(uindx, pindx));
    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Row-and-Column-Scaling preconditioner.
    \hat{A} = Dr*A*Dc
    \hat{b} = Dr*b
*/
PetscErrorCode petsc_pc_rcs(const PetscInt dof, const PetscInt cEq)
{
    Vec Dr, Dc;
    PetscInt numCol, *row;
    PetscReal *colNorm, *value;
    PetscReal tol, err1, err2;
    PetscInt i, iter, maxiter;

    tol = 0.1;
    maxiter = 10;

    PetscFunctionBeginUser;

    PetscCall(VecSet(psol[cEq].Dr, 1.0));
    PetscCall(VecSet(psol[cEq].Dc, 1.0));
    PetscCall(VecDuplicate(psol[cEq].Dr, &Dr));
    PetscCall(VecDuplicate(psol[cEq].Dc, &Dc));

    for (iter = 0; iter < maxiter; iter++)
    {
        /* Get infinity norm of each row */
        PetscCall(MatGetRowMaxAbs(psol[cEq].A, Dr, NULL));

        /* Get infinity norm of each column */
        PetscCall(MatGetSize(psol[cEq].A, NULL, &numCol));
        PetscCall(PetscMalloc1(numCol, &colNorm));
        PetscCall(MatGetColumnNorms(psol[cEq].A, NORM_INFINITY, colNorm));
        for (i = 0; i < plhs.mynNo; i++)
        {
            row = plhs.ltg + i;
            value = colNorm + plhs.ltg[i] * dof;
            PetscCall(VecSetValuesBlocked(Dc, 1, row, value, INSERT_VALUES));
        }
        PetscCall(VecAssemblyBegin(Dc));
        PetscCall(VecAssemblyEnd(Dc));

        /* Calculate 1/sqrt(Dr, Dc) */
        PetscCall(VecSqrtAbs(Dc));
        PetscCall(VecReciprocal(Dc));
        PetscCall(VecSqrtAbs(Dr));
        PetscCall(VecReciprocal(Dr));

        /* Scale A matrix */
        PetscCall(MatDiagonalScale(psol[cEq].A, Dr, Dc));
        PetscCall(VecPointwiseMult(psol[cEq].Dc, psol[cEq].Dc, Dc));
        PetscCall(VecPointwiseMult(psol[cEq].Dr, psol[cEq].Dr, Dr));

        /* Converged or not */
        PetscCall(VecShift(Dc, -1.0));
        PetscCall(VecShift(Dr, -1.0));
        PetscCall(VecNorm(Dc, NORM_INFINITY, &err1));
        PetscCall(VecNorm(Dr, NORM_INFINITY, &err2));
        if (err1 <= tol && err2 <= tol)
            break;
    }

    if (err1 > tol || err2 > tol)
    {
        PetscPrintf(MPI_COMM_WORLD, "ERROR <PETSC_PC_RCS>: "
                                    "did not converge to %g in %d iterations.\n"
                                    "ERROR <PETSC_PC_RCS>: "
                                    "err1 = %g, err2 = %g\n",
                    tol, maxiter, err1, err2);
    }

    /* Scale right hand side */
    PetscCall(VecPointwiseMult(psol[cEq].b, psol[cEq].b, psol[cEq].Dr));

    PetscCall(PetscFree(colNorm));
    PetscCall(VecDestroy(&Dr));
    PetscCall(VecDestroy(&Dc));

    PetscFunctionReturn(PETSC_SUCCESS);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

     Private functions for debugging

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

/*
    Debug: save vector to text file
*/
PetscErrorCode petsc_debug_save_vec(const char *filename, Vec vec)
{
    PetscFunctionBeginUser;

    PetscViewer viewer;
    PetscViewerASCIIOpen(MPI_COMM_WORLD, filename, &viewer);
    PetscViewerPushFormat(viewer, PETSC_VIEWER_ASCII_COMMON);
    VecView(vec, viewer);
    PetscViewerPopFormat(viewer);
    PetscViewerDestroy(&viewer);

    PetscFunctionReturn(PETSC_SUCCESS);
}

/*
    Debug: save matrix to text file
*/
PetscErrorCode petsc_debug_save_mat(const char *filename, Mat mat)
{
    PetscFunctionBeginUser;

    PetscViewer viewer;
    PetscViewerASCIIOpen(MPI_COMM_WORLD, filename, &viewer);
    PetscViewerPushFormat(viewer, PETSC_VIEWER_ASCII_DENSE);
    MatView(mat, viewer);
    PetscViewerPopFormat(viewer);
    PetscViewerDestroy(&viewer);

    PetscFunctionReturn(PETSC_SUCCESS);
}

/////////////////////////////////////////////////////////////////
//                   P e t s c I m p l                         //
/////////////////////////////////////////////////////////////////

//-----------
// PetscImpl
//-----------
// The PetscImpl private class hides PETSc data structures
// and functions.
//
class PetscLinearAlgebra::PetscImpl
{
public:
    // True if PESc has been initialized.
    static bool petsc_initialized;

    PetscImpl();
    void initialize(ComMod &com_mod, eqType &lEq);
    void set_preconditioner(consts::PreconditionerType prec_type);
    void solve(ComMod &com_mod, eqType &lEq, const Vector<int> &incL, const Vector<double> &res);
    void init_dir_and_coupneu_bc(ComMod &com_mod, const Vector<int> &incL, const Vector<double> &res);

    consts::PreconditionerType preconditioner_;

    // Local to global mapping
    Vector<int> ltg_;

    // Factor for Dirichlet BCs
    Array<double> W_;

    // Residue
    Array<double> R_;

    // Factor for Lumped Parameter BCs
    // Array<double> V_;
    // std::vector<Array<double>> lpVec;
    PetscInt nFacesRes;
    PetscReal** lpVec;
};

bool PetscLinearAlgebra::PetscImpl::petsc_initialized = false;

PetscLinearAlgebra::PetscImpl::PetscImpl()
{
}

//-------------------------
// init_dir_and_coupneu_bc
//-------------------------
//
void PetscLinearAlgebra::PetscImpl::init_dir_and_coupneu_bc(ComMod &com_mod,
                                                            const Vector<int> &incL, const Vector<double> &res)
{
    using namespace consts;
    using namespace fsi_linear_solver;

    int dof = com_mod.dof;
    int mynNo = com_mod.tnNo;
    auto &lhs = com_mod.lhs;

    if (lhs.nFaces != 0)
    {
        for (auto &face : lhs.face)
        {
            face.incFlag = true;
        }

        for (int faIn = 0; faIn < lhs.nFaces; faIn++)
        {
            if (incL(faIn) == 0)
            {
                lhs.face[faIn].incFlag = false;
            }
        }

        for (int faIn = 0; faIn < lhs.nFaces; faIn++)
        {
            auto &face = lhs.face[faIn];
            face.coupledFlag = false;
            if (!face.incFlag)
            {
                continue;
            }

            bool flag = (face.bGrp == BcType::BC_TYPE_Neu);

            if (flag && res(faIn) != 0.0)
            {
                face.res = res(faIn);
                face.coupledFlag = true;
            }
        }
    }

    W_ = 1.0;

    for (int faIn = 0; faIn < lhs.nFaces; faIn++)
    {
        auto &face = lhs.face[faIn];
        if (!face.incFlag)
        {
            continue;
        }

        int faDof = std::min(face.dof, dof);

        if (face.bGrp == BcType::BC_TYPE_Dir)
        {
            for (int a = 0; a < face.nNo; a++)
            {
                int Ac = face.glob(a);
                for (int i = 0; i < faDof; i++)
                {
                    W_(i, Ac) = W_(i, Ac) * face.val(i, a);
                }
            }
        }
    }

    // V_ = 0.0;
    bool isCoupledBC = false;
    PetscInt cc = 0;

    for (int faIn = 0; faIn < lhs.nFaces; faIn++)
    {
        auto &face = lhs.face[faIn];
        if (face.coupledFlag)
        { 
            cc++;
        }
    }
    
    nFacesRes = cc;

    PetscMalloc1(nFacesRes, &lpVec);
    cc = 0;
    for (int faIn = 0; faIn < lhs.nFaces; faIn++)
    {
        auto &face = lhs.face[faIn];
        if (face.coupledFlag)
        {
            PetscMalloc1(mynNo * dof, &lpVec[cc]);
            isCoupledBC = true;
            int faDof = std::min(face.dof, dof);

            for (int a = 0; a < face.nNo; a++)
            {
                int Ac = face.glob(a);
                for (int i = 0; i < faDof; i++)
                {
                    lpVec[cc][Ac * dof + i] = sqrt(fabs(res(faIn))) * face.val(i, a);
                }
            }
            cc++;
            std::cout << "mynNo: " << plhs.mynNo << " Face Nodes: " << face.nNo << " Face ID: " << faIn << std::endl;
        }
    }
}

//------------
// initialize
//------------
// Initialize PETSc and create a linear solver.
//
void PetscLinearAlgebra::PetscImpl::initialize(ComMod &com_mod, eqType &equation)
{
    if (!petsc_initialized)
    {
        petsc_destroy_all(com_mod.nEq);

        petsc_initialize(com_mod.lhs.nNo, com_mod.lhs.mynNo, com_mod.lhs.nnz, com_mod.nEq,
                         com_mod.ltg.data(), com_mod.lhs.map.data(), com_mod.lhs.rowPtr.data(),
                         com_mod.lhs.colPtr.data(), com_mod.eq[0].ls.config.data());

        petsc_initialized = true;
    }

    auto prec_type = preconditioner_;
    auto ls_type = equation.ls.LS_type;
    auto phys = equation.phys;
    auto &ls = equation.ls;

    // Find the equation number of `equation` in com_mod.eq[].
    //
    int eq_num = -1;

    for (int a = 0; a < com_mod.nEq; a++)
    {
        if (std::addressof(com_mod.eq[a]) == std::addressof(equation))
        {
            eq_num = a;
        }
    }

    petsc_create_linearsolver(ls_type, prec_type, ls.pc_params, ls.sD, ls.mItr, ls.relTol, ls.absTol,
                              phys, equation.dof, com_mod.lhs.nnz, eq_num, com_mod.nEq);
}

void PetscLinearAlgebra::PetscImpl::set_preconditioner(consts::PreconditionerType prec_type)
{
    preconditioner_ = prec_type;
}

//-------
// solve
//-------
//
void PetscLinearAlgebra::PetscImpl::solve(ComMod &com_mod, eqType &lEq, const Vector<int> &incL, const Vector<double> &res)
{
    W_.resize(com_mod.dof, com_mod.tnNo);
    // V_.resize(com_mod.dof, com_mod.tnNo);

    init_dir_and_coupneu_bc(com_mod, incL, res);

    // only excute once for each equation
    //
    petsc_create_linearsystem(com_mod.dof, com_mod.cEq, com_mod.nEq, W_.data(), lpVec, nFacesRes);

    petsc_set_values(com_mod.dof, com_mod.cEq, com_mod.R.data(), com_mod.Val.data(), W_.data(), lpVec);

    petsc_solve(&lEq.FSILS.RI.fNorm, &lEq.FSILS.RI.iNorm, &lEq.FSILS.RI.dB, &lEq.FSILS.RI.callD,
                &lEq.FSILS.RI.suc, &lEq.FSILS.RI.itr, com_mod.R.data(), lEq.FSILS.RI.mItr, com_mod.dof, com_mod.cEq);
}

//--------------------------------
// Block-Iterative Preconditioners
//--------------------------------

/*
    Schur Complement Reduction (SCR) preconditioner
*/
SCR_Preconditioner::~SCR_Preconditioner()
{
    // Clean up internal linear solvers
    delete solver_0;
    delete solver_1;

    auto A = getSubMatrix();

    // Clean up sub-matrices
    if (A) {
        for (PetscInt i = 0; i < 3; ++i) {
            if (A[i]) { 
                for (PetscInt j = 0; j < 3; ++j) {
                    MatDestroy(&A[i][j]); 
                }
                PetscFree(A[i]); 
            }
        }
        PetscFree(A);
        A = NULL;
    }

    // Clean up sub-vectors
    if (subR) {
        for (PetscInt i = 0; i < 2; ++i) {
            VecDestroy(&subR[i]); 
        }
        PetscFree(subR);
        subR = NULL;
    }

    if (subZ) {
        for (PetscInt i = 0; i < 2; ++i) {
            VecDestroy(&subZ[i]); 
        }
        PetscFree(subZ);
        subZ = NULL;
    }

    MatDestroy(&Ps);
    MatDestroy(&S);

};

PetscErrorCode SCR_Preconditioner::SCR_PCApply(PC pc, Vec r, Vec z)
{
    Vec z_0_temp, z_1_temp;
    PC pc_0, pc_1;

    PetscErrorCode ierr;

    PetscFunctionBeginUser;

    auto subA = getSubMatrix();

    PetscCall(VecNestGetSubVecs(r, NULL, &subR));
    PetscCall(VecNestGetSubVecs(z, NULL, &subZ));

    PetscCall(VecDuplicate(subZ[0], &z_0_temp));
    PetscCall(VecDuplicate(subZ[1], &z_1_temp));

    PetscCall(VecSet(z_0_temp, 0.0));
    PetscCall(VecSet(z_1_temp, 0.0)); 
    VecAssemblyBegin(z_0_temp); VecAssemblyEnd(z_0_temp);
    VecAssemblyBegin(z_1_temp); VecAssemblyEnd(z_1_temp);
    
    //-------------------------------------------------
    // Intermediate solver
    /*
     solver_0 -> A_00 * z_0 = r_0 
    */
    solver_0->SetOperator(subA[0][0]);
    set_internal_pc_type(solver_0, pc_0, pc_type_0);
    solver_0->Solve(subR[0], subZ[0], PETSC_FALSE);
    PetscCall(VecAssemblyBegin(subZ[0])); PetscCall(VecAssemblyEnd(subZ[0]));

    /*
     z_1 = r_1 - A_10 * z_0
    */
    MatMult(subA[1][0], subZ[0], z_1_temp);
    PetscCall(VecAssemblyBegin(z_1_temp)); PetscCall(VecAssemblyEnd(z_1_temp));

    PetscCall(VecWAXPY(subZ[1], -1.0, z_1_temp, subR[1]));
    PetscCall(VecAssemblyBegin(subZ[1])); PetscCall(VecAssemblyEnd(subZ[1]));

    //-------------------------------------------------
    // Inner solver 

    /*
      solver_1 -> S * z_1 = r_1 - A_10 * z_0 
      S = A_11 - A_10 * A_00^{-1} * A_01
      matrix-free alghorithm for S involves application
      of S to a vector x = r_1 - A_10 * z_0 and using
      GMRES solver to solve for z_1
    */
    solver_1->SetOperator(S, Ps);
    set_internal_pc_type(solver_1, pc_1, pc_type_1);
    solver_1->Solve(subZ[1], subZ[1], PETSC_FALSE);
    PetscCall(VecAssemblyBegin(subZ[1])); PetscCall(VecAssemblyEnd(subZ[1]));

    /* 
      z_0 = r_0 - A_01 * z_1
    */
    PetscCall(MatMult(subA[0][1], subZ[1], z_0_temp));
    PetscCall(VecAssemblyBegin(z_0_temp)); PetscCall(VecAssemblyEnd(z_0_temp));

    PetscCall(VecWAXPY(subZ[0], -1.0, z_0_temp, subR[0]));
    PetscCall(VecAssemblyBegin(subZ[0])); PetscCall(VecAssemblyEnd(subZ[0]));

    /*
     Solve A_00 * z_0 = r_0
    */
    set_internal_pc_type(solver_0, pc_0, pc_type_0);
    solver_0->Solve(subZ[0], subZ[0], PETSC_FALSE);
    PetscCall(VecAssemblyBegin(subZ[0])); PetscCall(VecAssemblyEnd(subZ[0]));
    
    // Clean up
    PetscCall(VecDestroy(&z_0_temp));
    PetscCall(VecDestroy(&z_1_temp));

    PetscFunctionReturn(PETSC_SUCCESS);
};

PetscErrorCode SCR_Preconditioner::SetApproximateSchur()
{
    Vec diagA, invDiagA;
    Mat BinvDiagA, CBinvDiagA;

    auto A = getSubMatrix();

    PetscCall(MatCreateVecs(A[0][0], &diagA, NULL));
    PetscCall(MatGetDiagonal(A[0][0], diagA));

    PetscCall(VecDuplicate(diagA, &invDiagA));
    PetscCall(VecCopy(diagA, invDiagA));
    PetscCall(VecReciprocal(invDiagA));

    PetscCall(MatDuplicate(A[0][1], MAT_COPY_VALUES, &BinvDiagA));
    PetscCall(MatDiagonalScale(BinvDiagA, invDiagA, NULL));

    PetscCall(MatMatMult(A[1][0], BinvDiagA, MAT_INITIAL_MATRIX, PETSC_DEFAULT, &CBinvDiagA));

    PetscCall(MatDuplicate(A[1][1], MAT_COPY_VALUES, &Ps));
    PetscCall(MatAXPY(Ps, -1.0, CBinvDiagA, DIFFERENT_NONZERO_PATTERN)); 

    // Cleanup
    PetscCall(VecDestroy(&diagA));
    PetscCall(VecDestroy(&invDiagA));
    PetscCall(MatDestroy(&BinvDiagA));
    PetscCall(MatDestroy(&CBinvDiagA));
}

PetscErrorCode SCR_Preconditioner::SCR_SchurApply(Mat mat, Vec x, Vec y)
{
    Vec v_0, v_1, v_1_tmp;
    PC pc_0;

    PetscFunctionBeginUser;

    SCR_Preconditioner *ctx;
    PetscCall(MatShellGetContext(mat, &ctx));

    auto A = ctx->getSubMatrix();

    VecCreate(MPI_COMM_WORLD, &v_0);
    VecSetSizes(v_0, ctx->GetSize(0), PETSC_DECIDE);
    VecSetUp(v_0);
    VecCreate(MPI_COMM_WORLD, &v_1);
    VecSetSizes(v_1, ctx->GetSize(1), PETSC_DECIDE);
    VecSetUp(v_1);
    VecDuplicate(v_1, &v_1_tmp);

    auto &solver_0 = ctx->solver_0;

    PetscCall(MatMult(A[1][1], x, v_1));
    PetscCall(MatMult(A[0][1], x, v_0));

    solver_0->SetOperator(A[0][0]);
    ctx->set_internal_pc_type(solver_0, pc_0, ctx->pc_type_0);
    solver_0->Solve(v_0, v_0, PETSC_FALSE);

    PetscCall(MatMult(A[1][0], v_0, v_1_tmp));

    PetscCall(VecWAXPY(y, -1.0, v_1_tmp, v_1));

    PetscFunctionReturn(PETSC_SUCCESS);

    VecDestroy(&v_0);
    VecDestroy(&v_1);
    VecDestroy(&v_1_tmp);
};

/*
    SIMPLE preconditioner
*/
SIMPLE_Preconditioner::~SIMPLE_Preconditioner()
{
    // Clean up internal linear solvers
    delete solver_0;

    auto A = getSubMatrix();

    // Clean up sub-matrices
    if (A) {
        for (PetscInt i = 0; i < 3; ++i) {
            if (A[i]) { 
                for (PetscInt j = 0; j < 3; ++j) {
                    MatDestroy(&A[i][j]); 
                }
                PetscFree(A[i]); 
            }
        }
        PetscFree(A);
        A = NULL;
    }

    // Clean up sub-vectors
    if (subR) {
        for (PetscInt i = 0; i < 2; ++i) {
            VecDestroy(&subR[i]); 
        }
        PetscFree(subR);
        subR = NULL;
    }

    if (subZ) {
        for (PetscInt i = 0; i < 2; ++i) {
            VecDestroy(&subZ[i]); 
        }
        PetscFree(subZ);
        subZ = NULL;
    }

    MatDestroy(&Ps);
};

PetscErrorCode SIMPLE_Preconditioner::SIMPLE_PCApply(PC pc, Vec r, Vec z)
{
    Vec z_0_temp, z_d_temp, z_1_temp;
    Vec diagA;
    Mat matB;

    PC pc_0, pc_1;

    PetscErrorCode ierr;

    PetscFunctionBeginUser;

    auto subA = getSubMatrix();

    // Getting subvectors from nested vectors
    PetscCall(VecNestGetSubVecs(r, NULL, &subR));
    PetscCall(VecNestGetSubVecs(z, NULL, &subZ));

    PetscCall(VecDuplicate(subZ[0], &z_0_temp));
    PetscCall(VecDuplicate(subZ[0], &z_d_temp));
    PetscCall(VecDuplicate(subZ[1], &z_1_temp));

    PetscCall(VecSet(z_0_temp, 0.0));
    PetscCall(VecSet(z_d_temp, 0.0));
    PetscCall(VecSet(z_1_temp, 0.0)); 
    VecAssemblyBegin(z_0_temp); VecAssemblyEnd(z_0_temp);
    VecAssemblyBegin(z_d_temp); VecAssemblyEnd(z_d_temp);
    VecAssemblyBegin(z_1_temp); VecAssemblyEnd(z_1_temp);
    
    //-------------------------------------------------
    // Intermediate solver
    /*
     -------------------------------------------------
     solver_0 -> A_00 * z_0 = r_0 
     -------------------------------------------------
    */
    solver_0->SetOperator(subA[0][0]);
    set_internal_pc_type(solver_0, pc_0, pc_type_0);
    solver_0->Solve(subR[0], subZ[0], PETSC_FALSE);
    PetscCall(VecAssemblyBegin(subZ[0])); PetscCall(VecAssemblyEnd(subZ[0]));

    /*
     -------------------------------------------------
     z_1 = r_1 - A_10 * z_0
     -------------------------------------------------
    */
    PetscCall(MatMult(subA[1][0], subZ[0], z_1_temp));
    PetscCall(VecAssemblyBegin(z_1_temp)); PetscCall(VecAssemblyEnd(z_1_temp));

    PetscCall(VecWAXPY(subZ[1], -1.0, z_1_temp, subR[1]));
    PetscCall(VecAssemblyBegin(subZ[1])); PetscCall(VecAssemblyEnd(subZ[1]));

    //-------------------------------------------------
    // Inner solver 

    /*
      -------------------------------------------------
      solver_1 -> Ps * z_1 = r_1 - A_10 * z_0 
      Ps = A_11 - A_10 * (diag(A_00))^{-1} * A_01
      where Ps is an approximation of the Schur complement
      and using GMRES solver to solve for z_1
      -------------------------------------------------
    */
    solver_1->SetOperator(Ps, Ps);
    set_internal_pc_type(solver_0, pc_0, pc_type_0);
    solver_1->Solve(subZ[1], subZ[1], PETSC_FALSE);
    PetscCall(VecAssemblyBegin(subZ[1])); PetscCall(VecAssemblyEnd(subZ[1]));

    // Update the momentum residual: z_0 = r_0 - A_00 * (diag(A_00))^-1 * A_01 * z_1
    PetscCall(MatCreateVecs(subA[0][0], &diagA, NULL));
    PetscCall(MatGetDiagonal(subA[0][0], diagA));
    PetscCall(VecReciprocal(diagA));
    PetscCall(MatDuplicate(subA[0][1], MAT_COPY_VALUES, &matB));
    PetscCall(MatDiagonalScale(matB, diagA, NULL));
    PetscCall(MatMult(matB, subZ[1], z_0_temp));
    PetscCall(MatMult(subA[0][0], z_0_temp, z_d_temp));
    PetscCall(VecWAXPY(subZ[0], -1.0, z_d_temp, subR[0]));
    PetscCall(VecAssemblyBegin(subZ[0])); PetscCall(VecAssemblyEnd(subZ[0]));

    /*
     -------------------------------------------------
     Solve A_00 * z_0 = r_0
     -------------------------------------------------
    */
    set_internal_pc_type(solver_0, pc_0, pc_type_0);
    solver_0->Solve(subZ[0], subZ[0], PETSC_FALSE);
    PetscCall(VecAssemblyBegin(subZ[0])); PetscCall(VecAssemblyEnd(subZ[0]));
    
    // Clean up
    PetscCall(VecDestroy(&z_0_temp));
    PetscCall(VecDestroy(&z_d_temp));
    PetscCall(VecDestroy(&z_1_temp));
    PetscCall(VecDestroy(&diagA));
    PetscCall(MatDestroy(&matB));

    PetscFunctionReturn(PETSC_SUCCESS);
};

PetscErrorCode SIMPLE_Preconditioner::SetApproximateSchur()
{
    Vec diagA, invDiagA;
    Mat BinvDiagA, CBinvDiagA;

    auto A = getSubMatrix();

    PetscCall(MatCreateVecs(A[0][0], &diagA, NULL));
    PetscCall(MatGetDiagonal(A[0][0], diagA));

    PetscCall(VecDuplicate(diagA, &invDiagA));
    PetscCall(VecCopy(diagA, invDiagA));
    PetscCall(VecReciprocal(invDiagA));

    PetscCall(MatDuplicate(A[0][1], MAT_COPY_VALUES, &BinvDiagA));
    PetscCall(MatDiagonalScale(BinvDiagA, invDiagA, NULL));

    PetscCall(MatMatMult(A[1][0], BinvDiagA, MAT_INITIAL_MATRIX, PETSC_DEFAULT, &CBinvDiagA));

    PetscCall(MatDuplicate(A[1][1], MAT_COPY_VALUES, &Ps));
    PetscCall(MatAXPY(Ps, -1.0, CBinvDiagA, DIFFERENT_NONZERO_PATTERN)); 

    // Cleanup
    PetscCall(VecDestroy(&diagA));
    PetscCall(VecDestroy(&invDiagA));
    PetscCall(MatDestroy(&BinvDiagA));
    PetscCall(MatDestroy(&CBinvDiagA));
}

/* 
    Setting PC parameters for the internal solvers
*/
PetscErrorCode BlockIterative_Preconditioner::set_internal_pc_type(PC_LSCtx *internal_solver, PC pc_internal, std::string pc_type) 
{
    static const std::unordered_map<std::string, PCType> pc_map = {
        {"jacobi",PCJACOBI},
        {"bjacobi", PCBJACOBI},
        {"amg", PCHYPRE},
        {"none", PCNONE},
        {"default", PCBJACOBI}
    };
    
    internal_solver->GetPC(&pc_internal);

    auto it = pc_map.find(pc_type);
    if (it != pc_map.end()) {
        PetscCall(PCSetType(pc_internal, it->second));
        if (pc_type == "amg") 
        {
            PetscCall(PCHYPRESetType(pc_internal, "boomeramg"));
        }
        PetscCall(PCSetFromOptions(pc_internal));
        return PETSC_SUCCESS;
    } else {
        throw std::runtime_error("[SCR_PC]: Unknown PC type: " + pc_type + " for internal solver.");
    }
}

/* 
    Internal Linear solver for the Block Nested Preconditioner:
    solver_0, solver_1
*/

PC_LSCtx::PC_LSCtx(
    const double &input_rtol, const double &input_atol,
    const double &input_dtol, const int &input_maxits,
    const char *const &ksp_prefix, const char *const &pc_prefix)
    : rtol(input_rtol), atol(input_atol),
      dtol(input_dtol), maxits(input_maxits)
{
    KSPCreate(MPI_COMM_WORLD, &ksp);
    KSPSetTolerances(ksp, rtol, atol, dtol, maxits);
    
    KSPSetType(ksp, KSPGMRES);
    KSPSetOptionsPrefix(ksp, ksp_prefix);
    
    PC ksp_pc;
    KSPGetPC(ksp, &ksp_pc);
    PCSetOptionsPrefix(ksp_pc, pc_prefix);
    KSPSetFromOptions(ksp);
    PCSetFromOptions(ksp_pc);
}

PC_LSCtx::~PC_LSCtx()
{
    KSPDestroy(&ksp);
};

PetscErrorCode PC_LSCtx::Solve(const Vec &in_R, Vec &out_Sol, const bool &isPrint)
{
    if (isPrint)
    {
        KSPSetComputeSingularValues(ksp, PETSC_TRUE);
    } 

    KSPSolve(ksp, in_R, out_Sol);
    
    if (isPrint)
    {
        PetscInt its;
        KSPGetIterationNumber(ksp, &its);
        PetscReal resnorm;
        KSPGetResidualNorm(ksp, &resnorm);
        PetscPrintf(MPI_COMM_WORLD, "  --- KSP: %d, %e \n", its, resnorm);
        get_ksp_estimate_condition();
    }
};

void PC_LSCtx::Monitor() const
{
    PetscViewerAndFormat *vf;
    PetscViewerAndFormatCreate(PETSC_VIEWER_STDOUT_WORLD, PETSC_VIEWER_DEFAULT, &vf);
    KSPMonitorSet(ksp, (PetscErrorCode(*)(KSP, PetscInt, PetscReal, void *))KSPMonitorDefault, vf, (PetscErrorCode(*)(void **))PetscViewerAndFormatDestroy);
};

void PC_LSCtx::get_ksp_estimate_condition() const
{
    PetscReal eig_max, eig_min, cond_num;

    KSPComputeExtremeSingularValues(ksp, &eig_max, &eig_min);
    cond_num = eig_max / eig_min;
    PetscPrintf(MPI_COMM_WORLD, "  --- KSP: Max Eigen = %g, Min Eigen = %g\n", eig_max, eig_min);
    PetscPrintf(MPI_COMM_WORLD, "  --- KSP: Condition Number Estimate %g\n", cond_num);

};

/* 
    PETSc general
*/
PetscErrorCode MatCreatePreallocator(PetscInt m, PetscInt n, Mat *A)
{
    PetscFunctionBeginUser;

    PetscCall(MatCreate(MPI_COMM_WORLD, A));
    PetscCall(MatSetType(*A, MATPREALLOCATOR));
    PetscCall(MatSetSizes(*A, m, n, PETSC_DECIDE, PETSC_DECIDE));
    PetscCall(MatSetUp(*A));

    PetscFunctionReturn(PETSC_SUCCESS);
}

PetscErrorCode MatCreatePreallocSubMat(PetscInt m, PetscInt n, Mat *A, Mat *preallocator)
{
    PetscFunctionBeginUser;

    PetscCall(MatCreate(MPI_COMM_WORLD, A));
    PetscCall(MatSetType(*A, MATAIJ));
    PetscCall(MatSetFromOptions(*A));
    PetscCall(MatSetSizes(*A, m, n, PETSC_DECIDE, PETSC_DECIDE));
    PetscCall(MatPreallocatorPreallocate(*preallocator, PETSC_TRUE, *A));
    PetscCall(MatSetOption(*A, MAT_NEW_NONZERO_LOCATION_ERR, PETSC_TRUE));
    PetscCall(MatSetOption(*A, MAT_NEW_NONZERO_LOCATIONS, PETSC_FALSE));

    PetscFunctionReturn(PETSC_SUCCESS);
}